(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("@gl-widget/gl-widget", [], factory);
	else if(typeof exports === 'object')
		exports["@gl-widget/gl-widget"] = factory();
	else
		root["@gl-widget/gl-widget"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Attribute.ts":
/*!**************************!*\
  !*** ./src/Attribute.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Attribute {\n    constructor(itemSize, normalized = false) {\n        this.itemSize = itemSize;\n        this.normalized = normalized;\n    }\n    setXY(index, x, y) {\n        index *= this.itemSize;\n        this.array[index + 0] = x;\n        this.array[index + 1] = y;\n        return this;\n    }\n    setXYZ(index, x, y, z) {\n        index *= this.itemSize;\n        this.array[index + 0] = x;\n        this.array[index + 1] = y;\n        this.array[index + 2] = z;\n        return this;\n    }\n}\nexports.Attribute = Attribute;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Attribute.ts?");

/***/ }),

/***/ "./src/Background.ts":
/*!***************************!*\
  !*** ./src/Background.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst RenderableElement_1 = __webpack_require__(/*! ./RenderableElement */ \"./src/RenderableElement.ts\");\nconst PlaneGeometry_1 = __webpack_require__(/*! ./extras/plugins/Geometries/PlaneGeometry */ \"./src/extras/plugins/Geometries/PlaneGeometry.ts\");\nclass Background extends RenderableElement_1.RenderableElement {\n    constructor(material = {}, geometry) {\n        material = Object.assign({\n            fragmentShader: 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}',\n            uniforms: {}\n        }, material);\n        super(material, geometry || new PlaneGeometry_1.PlaneGeometry(2, 2));\n    }\n}\nexports.Background = Background;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Background.ts?");

/***/ }),

/***/ "./src/BufferGeometry.ts":
/*!*******************************!*\
  !*** ./src/BufferGeometry.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Box3_1 = __webpack_require__(/*! ./math/Box3 */ \"./src/math/Box3.ts\");\nclass BufferGeometry {\n    constructor() {\n        this.attributes = new Map();\n        this.index = null;\n        this.boundingBox = new Box3_1.Box3();\n    }\n    addAttribute(name, attribute) {\n        if (name === 'index') {\n            this.index = attribute;\n        }\n        else {\n            this.attributes.set(name, attribute);\n        }\n    }\n}\nexports.BufferGeometry = BufferGeometry;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/BufferGeometry.ts?");

/***/ }),

/***/ "./src/BufferManager.ts":
/*!******************************!*\
  !*** ./src/BufferManager.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BufferManager {\n    constructor() {\n        this.buffers = new WeakMap();\n    }\n    initBuffer(gl, program, geometry) {\n        let count = 0;\n        for (let [name, attribute] of geometry.attributes.entries()) {\n            let array = attribute.array;\n            let buffer = gl.createBuffer();\n            if (!buffer) {\n                console.log('Failed to create the buffer object');\n                return -1;\n            }\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);\n            let location = gl.getAttribLocation(program, name);\n            if (location < 0) {\n                // console.log('Failed to get the storage location of ' + name);\n                // return -1;\n            }\n            else {\n                gl.vertexAttribPointer(location, attribute.itemSize, gl.FLOAT, false, 0, 0);\n                gl.enableVertexAttribArray(location);\n            }\n            if (array.length) {\n                count = array.length / attribute.itemSize;\n            }\n            this.buffers.set(attribute, buffer);\n        }\n        if (geometry.index) {\n            let buffer = gl.createBuffer();\n            if (!buffer) {\n                console.log('Failed to create the buffer object');\n                return -1;\n            }\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometry.index.array, gl.STATIC_DRAW);\n            this.buffers.set(geometry.index, buffer);\n            return {\n                hasIndex: true,\n                count: geometry.index.array.length\n            };\n        }\n        return {\n            hasIndex: false,\n            count: count\n        };\n    }\n    bindBuffer(gl, program, geometry) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.get(geometry.index));\n        for (let [name, attribute] of geometry.attributes.entries()) {\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.get(attribute));\n            let location = gl.getAttribLocation(program, name);\n            if (location < 0) {\n                // console.log('Failed to get the storage location of ' + name);\n                // return -1;\n            }\n            else {\n                gl.vertexAttribPointer(location, attribute.itemSize, gl.FLOAT, false, 0, 0);\n            }\n        }\n    }\n}\nexports.BufferManager = BufferManager;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/BufferManager.ts?");

/***/ }),

/***/ "./src/Clock.ts":
/*!**********************!*\
  !*** ./src/Clock.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Clock {\n    constructor(autoStart = true) {\n        this.autoStart = autoStart;\n        this.startTime = 0;\n        this.oldTime = 0;\n        this.elapsedTime = 0;\n        this.running = false;\n    }\n    start() {\n        this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732\n        this.oldTime = this.startTime;\n        this.elapsedTime = 0;\n        this.running = true;\n    }\n    stop() {\n        this.getElapsedTime();\n        this.running = false;\n        this.autoStart = false;\n    }\n    getElapsedTime() {\n        this.getDelta();\n        return this.elapsedTime;\n    }\n    getDelta() {\n        var diff = 0;\n        if (this.autoStart && !this.running) {\n            this.start();\n            return 0;\n        }\n        if (this.running) {\n            var newTime = (typeof performance === 'undefined' ? Date : performance).now();\n            diff = (newTime - this.oldTime) / 1000;\n            this.oldTime = newTime;\n            this.elapsedTime += diff;\n        }\n        return diff;\n    }\n}\nexports.Clock = Clock;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Clock.ts?");

/***/ }),

/***/ "./src/Constants.ts":
/*!**************************!*\
  !*** ./src/Constants.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar RenderSide;\n(function (RenderSide) {\n    RenderSide[RenderSide[\"FRONT\"] = 0] = \"FRONT\";\n    RenderSide[RenderSide[\"BACK\"] = 1] = \"BACK\";\n    RenderSide[RenderSide[\"DOUBLE\"] = 2] = \"DOUBLE\";\n})(RenderSide = exports.RenderSide || (exports.RenderSide = {}));\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Constants.ts?");

/***/ }),

/***/ "./src/Extensions.ts":
/*!***************************!*\
  !*** ./src/Extensions.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Extensions {\n    constructor(gl) {\n        this.extensions = {};\n        this.gl = gl;\n        this.get('WEBGL_depth_texture');\n        this.get('OES_texture_float');\n        this.get('OES_texture_float_linear');\n        this.get('OES_texture_half_float');\n        this.get('OES_texture_half_float_linear');\n        this.get('OES_standard_derivatives');\n        this.get('OES_element_index_uint');\n        this.get('ANGLE_instanced_arrays');\n    }\n    get(name) {\n        let gl = this.gl;\n        if (this.extensions[name] !== undefined) {\n            return this.extensions[name];\n        }\n        var extension;\n        switch (name) {\n            case 'WEBGL_depth_texture':\n                extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');\n                break;\n            case 'EXT_texture_filter_anisotropic':\n                extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');\n                break;\n            case 'WEBGL_compressed_texture_s3tc':\n                extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\n                break;\n            case 'WEBGL_compressed_texture_pvrtc':\n                extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n                break;\n            case 'WEBGL_compressed_texture_etc1':\n                extension = gl.getExtension('WEBGL_compressed_texture_etc1');\n                break;\n            default:\n                extension = gl.getExtension(name);\n        }\n        if (extension === null) {\n            console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');\n        }\n        this.extensions[name] = extension;\n        return extension;\n    }\n}\nexports.Extensions = Extensions;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Extensions.ts?");

/***/ }),

/***/ "./src/Float32Attribute.ts":
/*!*********************************!*\
  !*** ./src/Float32Attribute.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Attribute_1 = __webpack_require__(/*! ./Attribute */ \"./src/Attribute.ts\");\nclass Float32Attribute extends Attribute_1.Attribute {\n    constructor(array, itemSize, normalized = false) {\n        super(itemSize, normalized);\n        if (array instanceof Float32Array) {\n            this.array = array;\n        }\n        else {\n            this.array = new Float32Array(array);\n        }\n    }\n}\nexports.Float32Attribute = Float32Attribute;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Float32Attribute.ts?");

/***/ }),

/***/ "./src/Geometry.ts":
/*!*************************!*\
  !*** ./src/Geometry.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BufferGeometry_1 = __webpack_require__(/*! ./BufferGeometry */ \"./src/BufferGeometry.ts\");\nconst Float32Attribute_1 = __webpack_require__(/*! ./Float32Attribute */ \"./src/Float32Attribute.ts\");\nconst Uint32Attribute_1 = __webpack_require__(/*! ./Uint32Attribute */ \"./src/Uint32Attribute.ts\");\n/*\n{\n  positions: [...],\n  cells: [...],\n \n  // The following attributes are available when defined\n  // in the original file\n \n  vertexUVs: [...],     // array of UV coordinates\n  faceUVs: [...],       // array of UV indices\n  vertexNormals: [...], // array of vertex normals\n  faceNormals: [...],   // array of normal indices\n  name: 'foo'           // mesh name\n}\n*/\nclass Geometry {\n    constructor(data = {}, sameIndex = true) {\n        this.positions = data.positions || [];\n        this.cells = data.cells || [];\n        this.sameIndex = sameIndex;\n        this.vertexUVs = data.vertexUVs;\n        this.faceUVs = data.faceUVs;\n        this.vertexNormals = data.vertexNormals;\n        this.faceNormals = data.faceNormals;\n        this.normalIndices = data.normalIndices;\n    }\n    toBufferGeometry() {\n        let bufferGeometry = new BufferGeometry_1.BufferGeometry();\n        let position = [];\n        let normal = [];\n        let uv = [];\n        let index = [];\n        if (this.sameIndex) {\n            bufferGeometry.addAttribute('index', new Uint32Attribute_1.Uint32Attribute(this.cells.flat(), 1));\n            position = this.positions.flat();\n            if (this.vertexNormals) {\n                normal = this.vertexNormals.flat();\n            }\n            if (this.vertexUVs) {\n                uv = this.vertexUVs.flat();\n            }\n        }\n        else {\n            for (let i = 0; i < this.cells.length; i++) {\n                let faceIndices = this.cells[i];\n                faceIndices.forEach(index => {\n                    let p = this.positions[index];\n                    p.forEach(value => {\n                        position.push(value);\n                    });\n                });\n                if (this.normalIndices) {\n                    let normalIndices = this.normalIndices[i];\n                    console.log(normalIndices);\n                    normalIndices.forEach(index => {\n                        let n = this.vertexNormals[index];\n                        n.forEach(value => {\n                            normal.push(value);\n                        });\n                    });\n                }\n                if (this.faceUVs.length) {\n                    let uvIndices = this.faceUVs[i];\n                    uvIndices.forEach(index => {\n                        let u = this.vertexUVs[index];\n                        u.forEach(value => {\n                            uv.push(value);\n                        });\n                    });\n                }\n            }\n        }\n        bufferGeometry.addAttribute('position', new Float32Attribute_1.Float32Attribute(position, 3));\n        bufferGeometry.addAttribute('normal', new Float32Attribute_1.Float32Attribute(normal, 3));\n        bufferGeometry.addAttribute('uv', new Float32Attribute_1.Float32Attribute(uv, 2));\n        return bufferGeometry;\n    }\n}\nexports.Geometry = Geometry;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Geometry.ts?");

/***/ }),

/***/ "./src/Object3D.ts":
/*!*************************!*\
  !*** ./src/Object3D.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Matrix4_1 = __webpack_require__(/*! ./math/Matrix4 */ \"./src/math/Matrix4.ts\");\nconst Vector3_1 = __webpack_require__(/*! ./math/Vector3 */ \"./src/math/Vector3.ts\");\nconst Quaternion_1 = __webpack_require__(/*! ./math/Quaternion */ \"./src/math/Quaternion.ts\");\nclass Object3D {\n    constructor() {\n        this.changed = false;\n        this.matrix = new Matrix4_1.Matrix4();\n        this.matrixWorld = new Matrix4_1.Matrix4();\n        this.position = new Proxy(new Vector3_1.Vector3(), {\n            set: (target, key, value, receiver) => {\n                let v = Reflect.set(target, key, value, receiver);\n                this.updateMatrixWorld(true);\n                return v;\n            }\n        });\n        this.quaternion = new Proxy(new Quaternion_1.Quaternion(), {\n            set: (target, key, value, receiver) => {\n                let v = Reflect.set(target, key, value, receiver);\n                this.updateMatrixWorld(true);\n                return v;\n            }\n        });\n        this.scale = new Proxy(new Vector3_1.Vector3(1, 1, 1), {\n            set: (target, key, value, receiver) => {\n                let v = Reflect.set(target, key, value, receiver);\n                this.updateMatrixWorld(true);\n                return v;\n            }\n        });\n        this.parent = null;\n        this.children = [];\n        this.matrixAutoUpdate = true;\n    }\n    applyMatrix(matrix) {\n        this.matrix.multiplyMatrices(matrix, this.matrix);\n        this.matrix.decompose(this.position, this.quaternion, this.scale);\n    }\n    updateMatrix() {\n        this.changed = true;\n        this.matrix.compose(this.position, this.quaternion, this.scale);\n        this.matrixWorldNeedsUpdate = true;\n    }\n    updateMatrixWorld(force) {\n        if (this.matrixAutoUpdate)\n            this.updateMatrix();\n        if (this.matrixWorldNeedsUpdate || force) {\n            if (this.parent === null) {\n                this.matrixWorld.copy(this.matrix);\n            }\n            else {\n                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n            }\n            this.matrixWorldNeedsUpdate = false;\n            force = true;\n        }\n        // update children\n        var children = this.children;\n        for (var i = 0, l = children.length; i < l; i++) {\n            children[i].updateMatrixWorld(force);\n        }\n    }\n    rotateOnAxis(axis, angle) {\n        var q1 = new Quaternion_1.Quaternion();\n        q1.setFromAxisAngle(axis, angle);\n        this.quaternion.multiply(q1);\n        return this;\n    }\n    rotateOnWorldAxis(axis, angle) {\n        var q1 = new Quaternion_1.Quaternion();\n        q1.setFromAxisAngle(axis, angle);\n        this.quaternion.premultiply(q1);\n        return this;\n    }\n    rotateX(angle) {\n        var v1 = new Vector3_1.Vector3(1, 0, 0);\n        return this.rotateOnAxis(v1, angle);\n    }\n    rotateY(angle) {\n        var v1 = new Vector3_1.Vector3(0, 1, 0);\n        return this.rotateOnAxis(v1, angle);\n    }\n    rotateZ(angle) {\n        var v1 = new Vector3_1.Vector3(0, 0, 1);\n        return this.rotateOnAxis(v1, angle);\n    }\n    add(object) {\n        if (object) {\n            // if ( object.parent !== null ) {\n            // \tobject.parent.remove( object );\n            // }\n            object.parent = this;\n            // object.dispatchEvent( { type: 'added' } );\n            this.children.push(object);\n        }\n        return this;\n    }\n    traverse(callback) {\n        callback(this);\n        var children = this.children;\n        for (var i = 0, l = children.length; i < l; i++) {\n            children[i].traverse(callback);\n        }\n    }\n}\nexports.Object3D = Object3D;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Object3D.ts?");

/***/ }),

/***/ "./src/Program.ts":
/*!************************!*\
  !*** ./src/Program.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Shader_1 = __webpack_require__(/*! ./Shader */ \"./src/Shader.ts\");\nconst UniformManager_1 = __webpack_require__(/*! ./UniformManager */ \"./src/UniformManager.ts\");\nclass Program {\n    // bufferManager: BufferManager\n    constructor(gl, shader) {\n        this.program = gl.createProgram();\n        let vertexShader = new Shader_1.Shader(gl, gl.VERTEX_SHADER, shader.vertexShader);\n        let fragmentShader = new Shader_1.Shader(gl, gl.FRAGMENT_SHADER, shader.fragmentShader);\n        gl.attachShader(this.program, vertexShader);\n        gl.attachShader(this.program, fragmentShader);\n        gl.linkProgram(this.program);\n        let programLog = gl.getProgramInfoLog(this.program).trim();\n        if (gl.getProgramParameter(this.program, gl.LINK_STATUS) === false) {\n            console.error('shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(this.program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog);\n        }\n        else if (programLog !== '') {\n            console.warn('gl.getProgramInfoLog()', programLog);\n        }\n        gl.useProgram(this.program);\n        gl.deleteShader(vertexShader);\n        gl.deleteShader(fragmentShader);\n        this.uniformManager = new UniformManager_1.UniformManager(gl, this.program);\n        // this.bufferManager = new BufferManager()\n    }\n}\nexports.Program = Program;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Program.ts?");

/***/ }),

/***/ "./src/ProgramManager.ts":
/*!*******************************!*\
  !*** ./src/ProgramManager.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Program_1 = __webpack_require__(/*! ./Program */ \"./src/Program.ts\");\nclass ProgramManager {\n    constructor() {\n        this.programCache = new Map();\n    }\n    getProgram(gl, shader) {\n        let key = this.getProgramCacheKey(shader);\n        let program = this.programCache.get(key);\n        if (program) {\n        }\n        else {\n            program = new Program_1.Program(gl, shader);\n            this.programCache.set(key, program);\n        }\n        return program;\n    }\n    getProgramCacheKey(shader) {\n        let array = [];\n        array.push(shader.fragmentShader);\n        array.push(shader.vertexShader);\n        return array.join();\n    }\n}\nexports.ProgramManager = ProgramManager;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/ProgramManager.ts?");

/***/ }),

/***/ "./src/RenderFlow.ts":
/*!***************************!*\
  !*** ./src/RenderFlow.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst RenderTarget_1 = __webpack_require__(/*! ./RenderTarget */ \"./src/RenderTarget.ts\");\nconst Clock_1 = __webpack_require__(/*! ./Clock */ \"./src/Clock.ts\");\nclass RenderFlow {\n    constructor(renderer, renderTarget) {\n        this.renderer = renderer;\n        let parameters = {\n        // minFilter: LinearFilter,\n        // magFilter: LinearFilter,\n        // format: RGBAFormat,\n        // stencilBuffer: false\n        };\n        if (renderTarget === undefined) {\n            let size = renderer.getSize();\n            this.pixelRatio = renderer.getPixelRatio();\n            this.width = size.x;\n            this.height = size.y;\n            renderTarget = new RenderTarget_1.RenderTarget(renderer.gl, this.width * this.pixelRatio, this.height * this.pixelRatio, parameters);\n            // renderTarget.texture.name = 'EffectComposer.rt1';\n        }\n        else {\n            this.pixelRatio = 1;\n            this.width = renderTarget.width;\n            this.height = renderTarget.height;\n        }\n        this.renderTarget1 = renderTarget;\n        // this.renderTarget2 = renderTarget.clone();\n        this.renderTarget2 = new RenderTarget_1.RenderTarget(renderer.gl, this.width * this.pixelRatio, this.height * this.pixelRatio, parameters);\n        // this.renderTarget2.texture.name = 'EffectComposer.rt2';\n        this.writeBuffer = this.renderTarget1;\n        this.readBuffer = this.renderTarget2;\n        this.renderToScreen = true;\n        this.passes = [];\n        this.clock = new Clock_1.Clock();\n    }\n    swapBuffers() {\n        var tmp = this.readBuffer;\n        this.readBuffer = this.writeBuffer;\n        this.writeBuffer = tmp;\n    }\n    addPass(pass) {\n        this.passes.push(pass);\n        pass.setSize(this.width * this.pixelRatio, this.height * this.pixelRatio);\n    }\n    insertPass(pass, index) {\n        this.passes.splice(index, 0, pass);\n    }\n    isLastEnabledPass(passIndex) {\n        for (var i = passIndex + 1; i < this.passes.length; i++) {\n            if (this.passes[i].enabled) {\n                return false;\n            }\n        }\n        return true;\n    }\n    render(deltaTime) {\n        // deltaTime value is in seconds\n        if (deltaTime === undefined) {\n            deltaTime = this.clock.getDelta();\n        }\n        var currentRenderTarget = this.renderer.getRenderTarget();\n        var maskActive = false;\n        var pass, i, il = this.passes.length;\n        for (i = 0; i < il; i++) {\n            pass = this.passes[i];\n            if (pass.enabled === false)\n                continue;\n            pass.renderToScreen = (this.renderToScreen && this.isLastEnabledPass(i));\n            pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);\n            if (pass.needsSwap) {\n                // if ( maskActive ) {\n                // \tvar context = this.renderer.gl;\n                // \tvar stencil = this.renderer.state.buffers.stencil;\n                // \t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n                // \tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n                // \tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\n                // \t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n                // \tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n                // }\n                this.swapBuffers();\n            }\n            // if ( MaskPass !== undefined ) {\n            // \tif ( pass instanceof MaskPass ) {\n            // \t\tmaskActive = true;\n            // \t} else if ( pass instanceof ClearMaskPass ) {\n            // \t\tmaskActive = false;\n            // \t}\n            // }\n        }\n        this.renderer.setRenderTarget(currentRenderTarget);\n    }\n}\nexports.RenderFlow = RenderFlow;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/RenderFlow.ts?");

/***/ }),

/***/ "./src/RenderTarget.ts":
/*!*****************************!*\
  !*** ./src/RenderTarget.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Texture_1 = __webpack_require__(/*! ./Texture */ \"./src/Texture.ts\");\nconst TextureManager_1 = __webpack_require__(/*! ./TextureManager */ \"./src/TextureManager.ts\");\nclass RenderTarget {\n    constructor(gl, width, height, options = {}) {\n        this.gl = gl;\n        this.textureManager = new TextureManager_1.TextureManager(gl);\n        this.width = width;\n        this.height = height;\n        this.texture = new Texture_1.Texture();\n        this.textureManager.createTexture(this.texture, width, height);\n        this.frameBuffer = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.glTexture, null);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    }\n    setupDepthTexture(framebuffer, renderTarget) {\n    }\n    clone() {\n        let renderTarget = new RenderTarget(this.gl, this.width, this.height);\n        return renderTarget.copy(this);\n    }\n    copy(source) {\n        this.width = source.width;\n        this.height = source.height;\n        // this.viewport.copy( source.viewport );\n        this.texture = source.texture.clone();\n        // this.depthBuffer = source.depthBuffer;\n        // this.stencilBuffer = source.stencilBuffer;\n        // this.depthTexture = source.depthTexture;\n        return this;\n    }\n}\nexports.RenderTarget = RenderTarget;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/RenderTarget.ts?");

/***/ }),

/***/ "./src/RenderableElement.ts":
/*!**********************************!*\
  !*** ./src/RenderableElement.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BufferManager_1 = __webpack_require__(/*! ./BufferManager */ \"./src/BufferManager.ts\");\nconst Object3D_1 = __webpack_require__(/*! ./Object3D */ \"./src/Object3D.ts\");\nconst Constants_1 = __webpack_require__(/*! ./Constants */ \"./src/Constants.ts\");\nconst ProgramManager_1 = __webpack_require__(/*! ./ProgramManager */ \"./src/ProgramManager.ts\");\nconst Geometry_1 = __webpack_require__(/*! ./Geometry */ \"./src/Geometry.ts\");\nclass RenderableElement extends Object3D_1.Object3D {\n    constructor(material, geometry) {\n        super();\n        this.vertexShader = `\n        attribute vec4 position;\n        void main () {\n          gl_Position = position;\n        }\n      `;\n        if (material.fragmentShader) {\n            this.fragmentShader = material.fragmentShader;\n        }\n        if (material.vertexShader) {\n            this.vertexShader = material.vertexShader;\n        }\n        if (material.uniforms) {\n            this.uniforms = material.uniforms;\n        }\n        this.transparent = material.transparent || false;\n        this.side = material.side || Constants_1.RenderSide.FRONT;\n        if (geometry instanceof Geometry_1.Geometry) {\n            this.geometry = geometry;\n            this.bufferGeometry = this.geometry.toBufferGeometry();\n        }\n        else {\n            this.bufferGeometry = geometry;\n        }\n        this.programManager = new ProgramManager_1.ProgramManager();\n    }\n    getVertexNum() {\n        return this.vertexNum;\n    }\n    getProgram() {\n        return this.glProgram;\n    }\n    update(gl, material) {\n        let shader = material ? material : {\n            vertexShader: this.vertexShader,\n            fragmentShader: this.fragmentShader\n        };\n        this.program = this.programManager.getProgram(gl, shader);\n        this.glProgram = this.program.program;\n        // if (!this.program) {\n        //   this.program  = new Program(gl, shader)\n        //   this.glProgram = this.program.program\n        // }\n        gl.useProgram(this.glProgram);\n        this.updateBuffer(gl);\n        this.updateUniforms(gl);\n    }\n    updateBuffer(gl) {\n        if (!this.bufferManager) {\n            this.bufferManager = new BufferManager_1.BufferManager();\n            let format = this.bufferManager.initBuffer(gl, this.glProgram, this.bufferGeometry);\n            this.vertexNum = format.count;\n            this.hasIndex = format.hasIndex;\n        }\n        else {\n            this.bufferManager.bindBuffer(gl, this.glProgram, this.bufferGeometry);\n        }\n    }\n    updateUniforms(gl) {\n        this.program.uniformManager.updateUniforms(this.uniforms);\n    }\n}\nexports.RenderableElement = RenderableElement;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/RenderableElement.ts?");

/***/ }),

/***/ "./src/Renderer.ts":
/*!*************************!*\
  !*** ./src/Renderer.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Background_1 = __webpack_require__(/*! ./Background */ \"./src/Background.ts\");\nexports.Background = Background_1.Background;\nconst Clock_1 = __webpack_require__(/*! ./Clock */ \"./src/Clock.ts\");\nexports.Clock = Clock_1.Clock;\nconst Extensions_1 = __webpack_require__(/*! ./Extensions */ \"./src/Extensions.ts\");\nconst PerspectiveCamera_1 = __webpack_require__(/*! ./cameras/PerspectiveCamera */ \"./src/cameras/PerspectiveCamera.ts\");\nconst Matrix4_1 = __webpack_require__(/*! ./math/Matrix4 */ \"./src/math/Matrix4.ts\");\nconst RenderableElement_1 = __webpack_require__(/*! ./RenderableElement */ \"./src/RenderableElement.ts\");\nconst Object3D_1 = __webpack_require__(/*! ./Object3D */ \"./src/Object3D.ts\");\nexports.Object3D = Object3D_1.Object3D;\nconst SkyBox_1 = __webpack_require__(/*! ./SkyBox */ \"./src/SkyBox.ts\");\nconst Constants_1 = __webpack_require__(/*! ./Constants */ \"./src/Constants.ts\");\nconst Vector2_1 = __webpack_require__(/*! ./math/Vector2 */ \"./src/math/Vector2.ts\");\nvar CAMERA;\n(function (CAMERA) {\n    CAMERA[CAMERA[\"PERSPECTIVE\"] = 0] = \"PERSPECTIVE\";\n    CAMERA[CAMERA[\"ORTHOGRAPHIC\"] = 1] = \"ORTHOGRAPHIC\";\n})(CAMERA = exports.CAMERA || (exports.CAMERA = {}));\nclass Renderer {\n    constructor(options, attributes = {}) {\n        this.opaqueList = [];\n        this.transparentList = [];\n        this.renderTarget = null;\n        if (options.element instanceof HTMLCanvasElement) {\n            this.canvas = options.element;\n        }\n        else {\n            let element;\n            this.canvas = document.createElement('canvas');\n            if (options.element instanceof HTMLElement) {\n                element = options.element;\n            }\n            else {\n                element = document.getElementById(options.element);\n                if (!element) {\n                    console.error(options.element + ' not found!');\n                }\n            }\n            // this.canvas.style.position = 'absolute'\n            // this.canvas.style.top = '0'\n            // this.canvas.style.left = '0'\n            this.canvas.width = element.clientWidth;\n            this.canvas.height = element.clientHeight;\n            this.width = element.clientWidth;\n            this.height = element.clientHeight;\n            this.setPixelRatio(window.devicePixelRatio);\n            // this.setPixelRatio(1)\n            // this.canvas.width = element.clientWidth\n            // this.canvas.height = element.clientHeight\n            // element.appendChild(this.canvas)\n            let aspect = this.canvas.width / this.canvas.height;\n            this.defaultCamera = new PerspectiveCamera_1.PerspectiveCamera(50, aspect, 0.1, 1000);\n            this.defaultCamera.position.z = 10;\n            this.cameraMode = options.cameraMode || CAMERA.PERSPECTIVE;\n            element.insertBefore(this.canvas, element.firstChild);\n        }\n        let defaultAttributes = {\n            alpha: true,\n            depth: true,\n            stencil: true,\n            antialias: true,\n            premultipliedAlpha: true,\n            preserveDrawingBuffer: true\n        };\n        this.contextAttributes = Object.assign(defaultAttributes, attributes);\n        this.gl = options.gl\n            || this.canvas.getContext('webgl', this.contextAttributes)\n            || this.canvas.getContext('experimental-webgl', this.contextAttributes);\n        if (this.contextAttributes.depth) {\n            this.gl.enable(this.gl.DEPTH_TEST);\n        }\n        this.programs = new Map();\n        this.extensions = new Extensions_1.Extensions(this.gl); // TODO\n        this.gl.enable(this.gl.BLEND);\n        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n    }\n    setupMouse() {\n        let gl = this.gl;\n        let mouseEnter = {\n            x: 0,\n            y: 0\n        };\n        let mouseOld = {\n            x: 0,\n            y: 0\n        };\n        let mouseOffset = {\n            x: 0,\n            y: 0\n        };\n        let setMouseUniform = (x, y) => {\n            this.opaqueList.forEach(element => {\n                gl.useProgram(element.glProgram);\n                var location = gl.getUniformLocation(element.glProgram, 'mouse');\n                if (location != null) {\n                    gl.uniform2f(location, x, y);\n                }\n            });\n        };\n        setMouseUniform(0, 1);\n        let onMouseMove = (event) => {\n            mouseOffset.x = event.clientX - mouseEnter.x + mouseOld.x;\n            mouseOffset.y = event.clientY - mouseEnter.y + mouseOld.y;\n            setMouseUniform(mouseOffset.x / this.canvas.width, 1 - mouseOffset.y / this.canvas.height);\n        };\n        this.canvas.addEventListener('mousemove', onMouseMove, false);\n        this.canvas.addEventListener('mouseover', (event) => {\n            mouseEnter.x = event.clientX;\n            mouseEnter.y = event.clientY;\n        }, false);\n        this.canvas.addEventListener('mouseout', (event) => {\n            mouseOld.x = mouseOffset.x;\n            mouseOld.y = mouseOffset.y;\n        }, false);\n    }\n    setRenderTarget(renderTarget) {\n        if (!renderTarget) {\n            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n            this.renderTarget = null;\n        }\n        else {\n            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, renderTarget.frameBuffer);\n            this.renderTarget = renderTarget;\n        }\n    }\n    renderElement(element, camera, shader) {\n        let gl = this.gl;\n        let pvMatrix = new Matrix4_1.Matrix4();\n        // set depth test\n        if (element instanceof Background_1.Background) {\n            gl.disable(gl.DEPTH_TEST);\n        }\n        else {\n            gl.enable(gl.DEPTH_TEST);\n            pvMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n        }\n        element.update(gl, shader);\n        // set matrix\n        let mvpMatrix;\n        if (element instanceof SkyBox_1.SkyBox) {\n            let matrixWorldInverse = new Matrix4_1.Matrix4();\n            matrixWorldInverse.extractRotation(camera.matrixWorld);\n            matrixWorldInverse.getInverse(matrixWorldInverse);\n            mvpMatrix = new Matrix4_1.Matrix4();\n            mvpMatrix.multiplyMatrices(camera.projectionMatrix, matrixWorldInverse);\n            mvpMatrix.multiply(element.matrixWorld);\n        }\n        else {\n            mvpMatrix = pvMatrix.clone();\n            mvpMatrix.multiply(element.matrixWorld);\n        }\n        var location = gl.getUniformLocation(element.glProgram, 'mvpMatrix');\n        if (location != null) {\n            gl.uniformMatrix4fv(location, false, mvpMatrix.elements);\n        }\n        // set render side\n        switch (element.side) {\n            case Constants_1.RenderSide.FRONT:\n                gl.enable(gl.CULL_FACE);\n                gl.cullFace(gl.BACK);\n                break;\n            case Constants_1.RenderSide.BACK:\n                gl.enable(gl.CULL_FACE);\n                gl.cullFace(gl.FRONT);\n                break;\n            case Constants_1.RenderSide.DOUBLE:\n                gl.disable(gl.CULL_FACE);\n                break;\n        }\n        if (element.hasIndex) {\n            //draw    \n            gl.drawElements(gl.TRIANGLES, element.vertexNum, gl.UNSIGNED_INT, 0);\n        }\n        else {\n            gl.drawArrays(gl.TRIANGLES, 0, element.vertexNum);\n        }\n    }\n    getRenderTarget() {\n        return this.renderTarget;\n    }\n    setPixelRatio(value) {\n        if (value === undefined)\n            return;\n        this.pixelRatio = value;\n        this.setSize(this.width, this.height, false);\n    }\n    getPixelRatio() {\n        return this.pixelRatio;\n    }\n    setSize(width, height, updateStyle) {\n        this.width = width;\n        this.height = height;\n        this.canvas.width = Math.floor(width * this.pixelRatio);\n        this.canvas.height = Math.floor(height * this.pixelRatio);\n        this.canvas.style.width = width + 'px';\n        this.canvas.style.height = height + 'px';\n        // this.setViewport( 0, 0, width, height );\n    }\n    getSize() {\n        return new Vector2_1.Vector2(this.width, this.height);\n    }\n    render(background, scene, camera, once = false) {\n        let gl = this.gl;\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        let renderFrame = () => {\n            // let extensions = new Extensions(gl)\n            this.opaqueList = [];\n            this.transparentList = [];\n            // parse render list\n            if (background) {\n                this.opaqueList.push(background);\n            }\n            if (scene) {\n                scene.traverse((shape) => {\n                    if (shape instanceof RenderableElement_1.RenderableElement) {\n                        if (shape.transparent) {\n                            this.transparentList.push(shape);\n                        }\n                        else {\n                            this.opaqueList.push(shape);\n                        }\n                    }\n                });\n            }\n            camera = camera || this.defaultCamera;\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            this.opaqueList.forEach((element) => {\n                this.renderElement(element, camera);\n            });\n            this.transparentList.forEach((element) => {\n                this.renderElement(element, camera);\n            });\n            // animate\n            if (!once) {\n                requestAnimationFrame(renderFrame);\n            }\n        };\n        renderFrame();\n        // TODO remove\n        // this.setupMouse()\n    }\n}\nexports.Renderer = Renderer;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Renderer.ts?");

/***/ }),

/***/ "./src/Shader.ts":
/*!***********************!*\
  !*** ./src/Shader.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Shader {\n    constructor(gl, type, glslString) {\n        let shader = gl.createShader(type);\n        gl.shaderSource(shader, glslString);\n        gl.compileShader(shader);\n        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {\n            console.error('Shader couldn\\'t compile.');\n        }\n        if (gl.getShaderInfoLog(shader) !== '') {\n            console.warn('gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader));\n            gl.deleteShader(shader);\n        }\n        return shader;\n    }\n}\nexports.Shader = Shader;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Shader.ts?");

/***/ }),

/***/ "./src/SkyBox.ts":
/*!***********************!*\
  !*** ./src/SkyBox.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst SkyboxGeometry_1 = __webpack_require__(/*! ./SkyboxGeometry */ \"./src/SkyboxGeometry.ts\");\nconst Background_1 = __webpack_require__(/*! ./Background */ \"./src/Background.ts\");\nclass SkyBox extends Background_1.Background {\n    constructor(material = {}, geometry) {\n        material = Object.assign({\n            vertexShader: `\n        uniform mat4 mvpMatrix;\n        attribute vec4 position;\n        varying vec4 vTexCoords;\n        void main () {\n          vTexCoords = position;\n          gl_Position = mvpMatrix*position;\n        }\n      `,\n            fragmentShader: `\n        #ifdef GL_ES\n        precision mediump float;\n        #endif\n        uniform samplerCube cube;\n        varying vec4 vTexCoords;\n        void main() {\n          gl_FragColor = textureCube(cube, vTexCoords.xyz);\n        }\n      `\n        }, material);\n        super(material, geometry || new SkyboxGeometry_1.SkyboxGeometry());\n    }\n}\nexports.SkyBox = SkyBox;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/SkyBox.ts?");

/***/ }),

/***/ "./src/SkyboxGeometry.ts":
/*!*******************************!*\
  !*** ./src/SkyboxGeometry.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Uint32Attribute_1 = __webpack_require__(/*! ./Uint32Attribute */ \"./src/Uint32Attribute.ts\");\nconst Float32Attribute_1 = __webpack_require__(/*! ./Float32Attribute */ \"./src/Float32Attribute.ts\");\nconst BufferGeometry_1 = __webpack_require__(/*! ./BufferGeometry */ \"./src/BufferGeometry.ts\");\nclass SkyboxGeometry extends BufferGeometry_1.BufferGeometry {\n    constructor() {\n        super();\n        this.addAttribute('position', new Float32Attribute_1.Float32Attribute([\n            1, -1, 1,\n            -1, -1, 1,\n            -1, -1, -1,\n            1, -1, -1,\n            1, 1, 1,\n            -1, 1, 1,\n            -1, 1, -1,\n            1, 1, -1,\n        ], 3));\n        this.addAttribute('index', new Uint32Attribute_1.Uint32Attribute([\n            0, 3, 2, 0, 2, 1, 4, 0, 5, 0, 1, 5, 5, 1, 2, 5, 2, 6, 6, 2, 3, 6, 3, 7, 7, 3, 0, 7, 0, 4, 4, 5, 6, 4, 6, 7\n        ], 1));\n    }\n}\nexports.SkyboxGeometry = SkyboxGeometry;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/SkyboxGeometry.ts?");

/***/ }),

/***/ "./src/Texture.ts":
/*!************************!*\
  !*** ./src/Texture.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Texture {\n    constructor(imageSrc, format = 1, type = 1) {\n        this.state = new Proxy({\n            needsUpdate: false,\n            version: 0\n        }, {\n            set: (target, key, value, receiver) => {\n                let v = Reflect.set(target, key, value, receiver);\n                if (key === 'needsUpdate' && value === true) {\n                    this.version++;\n                    // console.log('version', this.version)\n                }\n                return v;\n            }\n        });\n        this.version = 0;\n        this.imageLoadedCount = 0;\n        this.image = null;\n        this.images = [];\n        if (imageSrc instanceof Array) {\n            this.imageCount = imageSrc.length;\n            imageSrc.forEach(src => {\n                let image = new Image();\n                image.onload = () => {\n                    // console.log('onload')\n                    this.loadedCallback();\n                    image.onload = null;\n                };\n                image.src = src;\n                this.images.push(image);\n            });\n        }\n        else if (imageSrc) {\n            let image = new Image();\n            image.onload = () => {\n                // console.log('onload')\n                this.loadedCallback();\n                image.onload = null;\n            };\n            image.src = imageSrc;\n            this.image = image;\n            this.imageCount = 1;\n        }\n        this.format = format;\n        this.type = type;\n        this.needsUpdate = false;\n        this.glTexture = null;\n    }\n    loadedCallback() {\n        this.imageLoadedCount += 1;\n        if (this.imageLoadedCount == this.imageCount) {\n            // console.log('image load')\n            this.state.needsUpdate = true;\n        }\n    }\n    clone() {\n        return new Texture(undefined).copy(this);\n    }\n    copy(source) {\n        // this.name = source.name;\n        this.image = source.image;\n        // this.mipmaps = source.mipmaps.slice( 0 );\n        // this.mapping = source.mapping;\n        // this.wrapS = source.wrapS;\n        // this.wrapT = source.wrapT;\n        // this.magFilter = source.magFilter;\n        // this.minFilter = source.minFilter;\n        // this.anisotropy = source.anisotropy;\n        this.format = source.format;\n        this.type = source.type;\n        // this.offset.copy( source.offset );\n        // this.repeat.copy( source.repeat );\n        // this.center.copy( source.center );\n        // this.rotation = source.rotation;\n        // this.matrixAutoUpdate = source.matrixAutoUpdate;\n        // this.matrix.copy( source.matrix );\n        // this.generateMipmaps = source.generateMipmaps;\n        // this.premultiplyAlpha = source.premultiplyAlpha;\n        // this.flipY = source.flipY;\n        // this.unpackAlignment = source.unpackAlignment;\n        // this.encoding = source.encoding;\n        return this;\n    }\n}\nexports.Texture = Texture;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Texture.ts?");

/***/ }),

/***/ "./src/TextureManager.ts":
/*!*******************************!*\
  !*** ./src/TextureManager.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst WebGL_1 = __importDefault(__webpack_require__(/*! ./WebGL */ \"./src/WebGL.ts\"));\nclass TextureManager {\n    constructor(gl) {\n        this.unit = 0;\n        this.gl = gl;\n        this.textureCache = new WeakMap();\n    }\n    createTexture(texture, width, height) {\n        let gl = this.gl;\n        texture.glTexture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture.glTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n    setTexture2D(texture, options) {\n        // if (!texture) return\n        let gl = this.gl;\n        let cached = this.textureCache.get(texture);\n        let currentUnit = this.unit;\n        if (!cached) {\n            cached = {\n                version: 0\n            };\n            // console.log(texture)\n            this.textureCache.set(texture, cached);\n            this.unit++;\n            // console.log(this.unit)\n        }\n        // if (! texture.image)console.log(texture)\n        // texture.glTexture =texture.glTexture ? texture.glTexture : gl.createTexture()\n        // let glTexture = cached.glTexture\n        // gl.generateMipmap( gl.TEXTURE_2D )\n        if (texture.image && texture.version > 0 && cached.version != texture.version) {\n            // console.log(cached.version, texture.version)\n            texture.glTexture = texture.glTexture ? texture.glTexture : gl.createTexture();\n            gl.activeTexture(gl.TEXTURE0 + currentUnit);\n            gl.bindTexture(gl.TEXTURE_2D, texture.glTexture);\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n            cached.version = texture.version;\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            // gl.generateMipmap( gl.TEXTURE_2D )\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n        }\n        gl.activeTexture(gl.TEXTURE0 + currentUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture.glTexture || WebGL_1.default.getInstance(gl).getEmptyTexture(gl.TEXTURE_2D));\n    }\n    setTextureCube(texture, options) {\n        let gl = this.gl;\n        let cached = this.textureCache.get(texture);\n        let currentUnit = this.unit;\n        if (!cached) {\n            cached = {\n                version: 0\n            };\n            this.textureCache.set(texture, cached);\n            this.unit++;\n        }\n        if (texture.images.length && texture.version > 0 && cached.version != texture.version) {\n            texture.glTexture = texture.glTexture ? texture.glTexture : gl.createTexture();\n            // texture.glTexture = glTexture\n            gl.activeTexture(gl.TEXTURE0 + this.unit);\n            gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture.glTexture);\n            for (let i = 0; i < 6; i++) {\n                let image = texture.images[i];\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n                cached.version = texture.version;\n            }\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            // gl.generateMipmap( gl.TEXTURE_CUBE_MAP )\n        }\n        gl.activeTexture(gl.TEXTURE0 + currentUnit);\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture.glTexture || WebGL_1.default.getInstance(gl).getEmptyTexture(gl.TEXTURE_CUBE_MAP));\n    }\n}\nexports.TextureManager = TextureManager;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/TextureManager.ts?");

/***/ }),

/***/ "./src/Uint32Attribute.ts":
/*!********************************!*\
  !*** ./src/Uint32Attribute.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Attribute_1 = __webpack_require__(/*! ./Attribute */ \"./src/Attribute.ts\");\nclass Uint32Attribute extends Attribute_1.Attribute {\n    constructor(array, itemSize, normalized = false) {\n        super(itemSize, normalized);\n        if (array instanceof Uint32Array) {\n            this.array = array;\n        }\n        else {\n            this.array = new Uint32Array(array);\n        }\n    }\n}\nexports.Uint32Attribute = Uint32Attribute;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/Uint32Attribute.ts?");

/***/ }),

/***/ "./src/UniformManager.ts":
/*!*******************************!*\
  !*** ./src/UniformManager.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TextureManager_1 = __webpack_require__(/*! ./TextureManager */ \"./src/TextureManager.ts\");\nconst Texture_1 = __webpack_require__(/*! ./Texture */ \"./src/Texture.ts\");\nlet emptyTexture = new Texture_1.Texture();\n// --- Setters ---\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n// Single scalar\nfunction setValue1f(gl, v) { gl.uniform1f(this.addr, v); }\nfunction setValue1i(gl, v) { gl.uniform1i(this.addr, v); }\n// Single float vector (from flat array or THREE.VectorN)\nfunction setValue2fv(gl, v) {\n    if (v.x === undefined)\n        gl.uniform2fv(this.addr, v);\n    else\n        gl.uniform2f(this.addr, v.x, v.y);\n}\nfunction setValue3fv(gl, v) {\n    if (v.x !== undefined)\n        gl.uniform3f(this.addr, v.x, v.y, v.z);\n    else if (v.r !== undefined)\n        gl.uniform3f(this.addr, v.r, v.g, v.b);\n    else\n        gl.uniform3fv(this.addr, v);\n}\nfunction setValue4fv(gl, v) {\n    if (v.x === undefined)\n        gl.uniform4fv(this.addr, v);\n    else\n        gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);\n}\n// Single matrix (from flat array or MatrixN)\nfunction setValue2fm(gl, v) {\n    gl.uniformMatrix2fv(this.addr, false, v.elements || v);\n}\nfunction setValue3fm(gl, v) {\n    gl.uniformMatrix3fv(this.addr, false, v.elements || v);\n}\nfunction setValue4fm(gl, v) {\n    gl.uniformMatrix4fv(this.addr, false, v.elements || v);\n}\n// Single texture (2D / Cube)\nfunction setValueT1(gl, v, textureManager) {\n    gl.uniform1i(this.addr, textureManager.unit);\n    textureManager.setTexture2D(v || emptyTexture);\n}\nfunction setValueT6(gl, v, textureManager) {\n    gl.uniform1i(this.addr, textureManager.unit);\n    textureManager.setTextureCube(v);\n}\n// Integer / Boolean vectors or arrays thereof (always flat arrays)\nfunction setValue2iv(gl, v) { gl.uniform2iv(this.addr, v); }\nfunction setValue3iv(gl, v) { gl.uniform3iv(this.addr, v); }\nfunction setValue4iv(gl, v) { gl.uniform4iv(this.addr, v); }\nfunction getSingularSetter(type) {\n    switch (type) {\n        case 0x1406: return setValue1f; // FLOAT\n        case 0x8b50: return setValue2fv; // _VEC2\n        case 0x8b51: return setValue3fv; // _VEC3\n        case 0x8b52: return setValue4fv; // _VEC4\n        case 0x8b5a: return setValue2fm; // _MAT2\n        case 0x8b5b: return setValue3fm; // _MAT3\n        case 0x8b5c: return setValue4fm; // _MAT4\n        case 0x8b5e: return setValueT1; // SAMPLER_2D\n        case 0x8b60: return setValueT6; // SAMPLER_CUBE\n        case 0x1404:\n        case 0x8b56: return setValue1i; // INT, BOOL\n        case 0x8b53:\n        case 0x8b57: return setValue2iv; // _VEC2\n        case 0x8b54:\n        case 0x8b58: return setValue3iv; // _VEC3\n        case 0x8b55:\n        case 0x8b59: return setValue4iv; // _VEC4\n    }\n}\nfunction SingleUniform(id, activeInfo, addr) {\n    this.id = id;\n    this.addr = addr;\n    this.setValue = getSingularSetter(activeInfo.type);\n    // this.path = activeInfo.name; // DEBUG\n}\n// --- Utilities ---\n// Array Caches (provide typed arrays for temporary by size)\nvar arrayCacheF32 = [];\nvar arrayCacheI32 = [];\n// Flattening for arrays of vectors and matrices\nfunction flatten(array, nBlocks, blockSize) {\n    var firstElem = array[0];\n    if (firstElem <= 0 || firstElem > 0)\n        return array;\n    // unoptimized: ! isNaN( firstElem )\n    // see http://jacksondunstan.com/articles/983\n    var n = nBlocks * blockSize, r = arrayCacheF32[n];\n    if (r === undefined) {\n        r = new Float32Array(n);\n        arrayCacheF32[n] = r;\n    }\n    if (nBlocks !== 0) {\n        firstElem.toArray(r, 0);\n        for (var i = 1, offset = 0; i !== nBlocks; ++i) {\n            offset += blockSize;\n            array[i].toArray(r, offset);\n        }\n    }\n    return r;\n}\n// Array of scalars\nfunction setValue1fv(gl, v) { gl.uniform1fv(this.addr, v); }\nfunction setValue1iv(gl, v) { gl.uniform1iv(this.addr, v); }\n// Array of vectors (flat or from THREE classes)\nfunction setValueV2a(gl, v) {\n    gl.uniform2fv(this.addr, flatten(v, this.size, 2));\n}\nfunction setValueV3a(gl, v) {\n    gl.uniform3fv(this.addr, flatten(v, this.size, 3));\n}\nfunction setValueV4a(gl, v) {\n    gl.uniform4fv(this.addr, flatten(v, this.size, 4));\n}\n// Array of matrices (flat or from THREE clases)\nfunction setValueM2a(gl, v) {\n    gl.uniformMatrix2fv(this.addr, false, flatten(v, this.size, 4));\n}\nfunction setValueM3a(gl, v) {\n    gl.uniformMatrix3fv(this.addr, false, flatten(v, this.size, 9));\n}\nfunction setValueM4a(gl, v) {\n    gl.uniformMatrix4fv(this.addr, false, flatten(v, this.size, 16));\n}\n// Array of textures (2D / Cube)\n// function setValueT1a( gl, v, renderer ) {\n// \tvar n = v.length,\n// \t\tunits = allocTexUnits( renderer, n );\n// \tgl.uniform1iv( this.addr, units );\n// \tfor ( var i = 0; i !== n; ++ i ) {\n// \t\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n// \t}\n// }\n// function setValueT6a( gl, v, renderer ) {\n// \tvar n = v.length,\n// \t\tunits = allocTexUnits( renderer, n );\n// \tgl.uniform1iv( this.addr, units );\n// \tfor ( var i = 0; i !== n; ++ i ) {\n// \t\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n// \t}\n// }\nfunction getPureArraySetter(type) {\n    switch (type) {\n        case 0x1406: return setValue1fv; // FLOAT\n        case 0x8b50: return setValueV2a; // _VEC2\n        case 0x8b51: return setValueV3a; // _VEC3\n        case 0x8b52: return setValueV4a; // _VEC4\n        case 0x8b5a: return setValueM2a; // _MAT2\n        case 0x8b5b: return setValueM3a; // _MAT3\n        case 0x8b5c: return setValueM4a; // _MAT4\n        // case 0x8b5e: return setValueT1a; // SAMPLER_2D\n        // case 0x8b60: return setValueT6a; // SAMPLER_CUBE\n        case 0x1404:\n        case 0x8b56: return setValue1iv; // INT, BOOL\n        case 0x8b53:\n        case 0x8b57: return setValue2iv; // _VEC2\n        case 0x8b54:\n        case 0x8b58: return setValue3iv; // _VEC3\n        case 0x8b55:\n        case 0x8b59: return setValue4iv; // _VEC4\n    }\n}\nfunction PureArrayUniform(id, activeInfo, addr) {\n    this.id = id;\n    this.addr = addr;\n    this.size = activeInfo.size;\n    this.setValue = getPureArraySetter(activeInfo.type);\n    // this.path = activeInfo.name; // DEBUG\n}\nclass UniformManager {\n    constructor(gl, program) {\n        this.textureManager = new TextureManager_1.TextureManager(gl);\n        this.gl = gl;\n        this.map = {};\n        this.seq = [];\n        var n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n        for (var i = 0; i !== n; ++i) {\n            var info = gl.getActiveUniform(program, i), path = info.name, addr = gl.getUniformLocation(program, path);\n            this.parseUniform(info, addr, this);\n        }\n    }\n    addUniform(container, uniformObject) {\n        container.seq.push(uniformObject);\n        container.map[uniformObject.id] = uniformObject;\n    }\n    parseUniform(activeInfo, addr, container) {\n        var RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n        var path = activeInfo.name, pathLength = path.length;\n        // reset RegExp object, because of the early exit of a previous run\n        RePathPart.lastIndex = 0;\n        for (;;) {\n            var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === ']', subscript = match[3];\n            if (idIsIndex)\n                id = id + 0; // convert to integer\n            if (subscript === undefined ||\n                subscript === '[' && matchEnd + 2 === pathLength) {\n                // bare name or \"pure\" bottom-level array \"[0]\" suffix\n                this.addUniform(container, subscript === undefined ?\n                    new SingleUniform(id, activeInfo, addr) :\n                    new PureArrayUniform(id, activeInfo, addr));\n                break;\n            }\n            else {\n                // step into inner node / create it in case it doesn't exist\n                var map = container.map, next = map[id];\n                if (next === undefined) {\n                    // next = new StructuredUniform( id );\n                    // addUniform( container, next );\n                }\n                container = next;\n            }\n        }\n    }\n    updateUniforms(uniforms = {}) {\n        this.textureManager.unit = 0;\n        let seq = this.filterUniforms(Object.keys(uniforms));\n        for (var i = 0, n = seq.length; i !== n; ++i) {\n            var u = seq[i], v = uniforms[u.id];\n            if (v.needsUpdate !== false) {\n                // console.log(u.id)\n                u.setValue(this.gl, v.value, this.textureManager);\n            }\n        }\n    }\n    filterUniforms(ids) {\n        var r = [];\n        for (var i = 0, n = this.seq.length; i !== n; ++i) {\n            var u = this.seq[i];\n            if (ids.indexOf(u.id) != -1)\n                r.push(u);\n        }\n        return r;\n    }\n}\nexports.UniformManager = UniformManager;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/UniformManager.ts?");

/***/ }),

/***/ "./src/WebGL.ts":
/*!**********************!*\
  !*** ./src/WebGL.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass WebGL {\n    constructor(gl) {\n        this.gl = gl;\n        this.emptyTextures = [];\n        this.emptyTextures[gl.TEXTURE_2D] = this.createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);\n        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = this.createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);\n    }\n    getEmptyTexture(type) {\n        return this.emptyTextures[type];\n    }\n    createTexture(type, target, count) {\n        let gl = this.gl;\n        var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.\n        var texture = gl.createTexture();\n        gl.bindTexture(type, texture);\n        gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        for (var i = 0; i < count; i++) {\n            gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        }\n        return texture;\n    }\n    static getInstance(gl) {\n        if (!WebGL.webGL) {\n            WebGL.webGL = new WebGL(gl);\n            return WebGL.webGL;\n        }\n        else {\n            return WebGL.webGL;\n        }\n    }\n}\nexports.default = WebGL;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/WebGL.ts?");

/***/ }),

/***/ "./src/cameras/Camera.ts":
/*!*******************************!*\
  !*** ./src/cameras/Camera.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Matrix4_1 = __webpack_require__(/*! ../math/Matrix4 */ \"./src/math/Matrix4.ts\");\nconst Object3D_1 = __webpack_require__(/*! ../Object3D */ \"./src/Object3D.ts\");\nconst Vector3_1 = __webpack_require__(/*! ../math/Vector3 */ \"./src/math/Vector3.ts\");\nclass Camera extends Object3D_1.Object3D {\n    constructor() {\n        super();\n        this.up = new Vector3_1.Vector3(0, 1, 0);\n        this.projectionMatrix = new Matrix4_1.Matrix4();\n        this.matrixWorldInverse = new Matrix4_1.Matrix4();\n        // this.matrixWorld = new Matrix4()\n        // this.matrixWorld.makeTranslation(0, 0, 10)\n        this.target = new Vector3_1.Vector3();\n        // this.position.z = 10\n    }\n    lookTarget(target) {\n        target = target || this.target;\n        var m1 = new Matrix4_1.Matrix4();\n        m1.lookAt(this.position, target, this.up);\n        this.quaternion.setFromRotationMatrix(m1);\n    }\n    updateMatrixWorld(force) {\n        super.updateMatrixWorld(force);\n        this.matrixWorldInverse.getInverse(this.matrixWorld);\n    }\n}\nexports.Camera = Camera;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/cameras/Camera.ts?");

/***/ }),

/***/ "./src/cameras/OrthographicCamera.ts":
/*!*******************************************!*\
  !*** ./src/cameras/OrthographicCamera.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Camera_1 = __webpack_require__(/*! ./Camera */ \"./src/cameras/Camera.ts\");\nclass OrthographicCamera extends Camera_1.Camera {\n    constructor(left, right, top, bottom, near, far) {\n        super();\n        this.zoom = 1;\n        this.left = left;\n        this.right = right;\n        this.top = top;\n        this.bottom = bottom;\n        this.near = (near !== undefined) ? near : 0.1;\n        this.far = (far !== undefined) ? far : 2000;\n        // this.lookTarget()\n        this.updateProjectionMatrix();\n    }\n    updateProjectionMatrix() {\n        var dx = (this.right - this.left) / (2 * this.zoom);\n        var dy = (this.top - this.bottom) / (2 * this.zoom);\n        var cx = (this.right + this.left) / 2;\n        var cy = (this.top + this.bottom) / 2;\n        var left = cx - dx;\n        var right = cx + dx;\n        var top = cy + dy;\n        var bottom = cy - dy;\n        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);\n    }\n}\nexports.OrthographicCamera = OrthographicCamera;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/cameras/OrthographicCamera.ts?");

/***/ }),

/***/ "./src/cameras/PerspectiveCamera.ts":
/*!******************************************!*\
  !*** ./src/cameras/PerspectiveCamera.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Camera_1 = __webpack_require__(/*! ./Camera */ \"./src/cameras/Camera.ts\");\nclass PerspectiveCamera extends Camera_1.Camera {\n    constructor(fov, aspect, near, far) {\n        super();\n        this.fov = fov !== undefined ? fov : 50;\n        this.zoom = 1;\n        this.near = near !== undefined ? near : 0.1;\n        this.far = far !== undefined ? far : 2000;\n        this.focus = 10;\n        this.aspect = aspect !== undefined ? aspect : 1;\n        // this.view = null;\n        this.filmGauge = 35; // width of the film (default in millimeters)\n        this.filmOffset = 0; // horizontal film offset (same unit as gauge)\n        this.updateProjectionMatrix();\n    }\n    getFilmWidth() {\n        // film not completely covered in portrait format (aspect < 1)\n        return this.filmGauge * Math.min(this.aspect, 1);\n    }\n    updateProjectionMatrix() {\n        var near = this.near, top = near * Math.tan(Math.PI / 180 * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width;\n        // \tview = this.view;\n        // if ( this.view !== null && this.view.enabled ) {\n        // \tvar fullWidth = view.fullWidth,\n        // \t\tfullHeight = view.fullHeight;\n        // \tleft += view.offsetX * width / fullWidth;\n        // \ttop -= view.offsetY * height / fullHeight;\n        // \twidth *= view.width / fullWidth;\n        // \theight *= view.height / fullHeight;\n        // }\n        var skew = this.filmOffset;\n        if (skew !== 0)\n            left += near * skew / this.getFilmWidth();\n        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n    }\n}\nexports.PerspectiveCamera = PerspectiveCamera;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/cameras/PerspectiveCamera.ts?");

/***/ }),

/***/ "./src/extras/plugins/Geometries/PlaneGeometry.ts":
/*!********************************************************!*\
  !*** ./src/extras/plugins/Geometries/PlaneGeometry.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BufferGeometry_1 = __webpack_require__(/*! ../../../BufferGeometry */ \"./src/BufferGeometry.ts\");\nconst Float32Attribute_1 = __webpack_require__(/*! ../../../Float32Attribute */ \"./src/Float32Attribute.ts\");\nconst Uint32Attribute_1 = __webpack_require__(/*! ../../../Uint32Attribute */ \"./src/Uint32Attribute.ts\");\nclass PlaneGeometry extends BufferGeometry_1.BufferGeometry {\n    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n        super();\n        var width_half = width / 2;\n        var height_half = height / 2;\n        var gridX = Math.floor(widthSegments) || 1;\n        var gridY = Math.floor(heightSegments) || 1;\n        var gridX1 = gridX + 1;\n        var gridY1 = gridY + 1;\n        var segment_width = width / gridX;\n        var segment_height = height / gridY;\n        var ix, iy;\n        // buffers\n        var indices = [];\n        var vertices = [];\n        var normals = [];\n        var uvs = [];\n        // generate vertices, normals and uvs\n        for (iy = 0; iy < gridY1; iy++) {\n            var y = iy * segment_height - height_half;\n            for (ix = 0; ix < gridX1; ix++) {\n                var x = ix * segment_width - width_half;\n                vertices.push(x, -y, 0);\n                normals.push(0, 0, 1);\n                uvs.push(ix / gridX);\n                uvs.push(1 - (iy / gridY));\n            }\n        }\n        // indices\n        for (iy = 0; iy < gridY; iy++) {\n            for (ix = 0; ix < gridX; ix++) {\n                var a = ix + gridX1 * iy;\n                var b = ix + gridX1 * (iy + 1);\n                var c = (ix + 1) + gridX1 * (iy + 1);\n                var d = (ix + 1) + gridX1 * iy;\n                // faces\n                indices.push(a, b, d);\n                indices.push(b, c, d);\n            }\n        }\n        this.addAttribute('position', new Float32Attribute_1.Float32Attribute(vertices, 3));\n        this.addAttribute('normal', new Float32Attribute_1.Float32Attribute(normals, 3));\n        this.addAttribute('uv', new Float32Attribute_1.Float32Attribute(uvs, 2));\n        this.addAttribute('index', new Uint32Attribute_1.Uint32Attribute(indices, 1));\n    }\n}\nexports.PlaneGeometry = PlaneGeometry;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/extras/plugins/Geometries/PlaneGeometry.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Renderer_1 = __webpack_require__(/*! ./Renderer */ \"./src/Renderer.ts\");\nexports.Renderer = Renderer_1.Renderer;\nconst PerspectiveCamera_1 = __webpack_require__(/*! ./cameras/PerspectiveCamera */ \"./src/cameras/PerspectiveCamera.ts\");\nexports.PerspectiveCamera = PerspectiveCamera_1.PerspectiveCamera;\nconst OrthographicCamera_1 = __webpack_require__(/*! ./cameras/OrthographicCamera */ \"./src/cameras/OrthographicCamera.ts\");\nexports.OrthographicCamera = OrthographicCamera_1.OrthographicCamera;\nconst Vector3_1 = __webpack_require__(/*! ./math/Vector3 */ \"./src/math/Vector3.ts\");\nexports.Vector3 = Vector3_1.Vector3;\nconst Clock_1 = __webpack_require__(/*! ./Clock */ \"./src/Clock.ts\");\nexports.Clock = Clock_1.Clock;\nconst Object3D_1 = __webpack_require__(/*! ./Object3D */ \"./src/Object3D.ts\");\nexports.Object3D = Object3D_1.Object3D;\nconst Vector2_1 = __webpack_require__(/*! ./math/Vector2 */ \"./src/math/Vector2.ts\");\nexports.Vector2 = Vector2_1.Vector2;\nconst Texture_1 = __webpack_require__(/*! ./Texture */ \"./src/Texture.ts\");\nexports.Texture = Texture_1.Texture;\nconst RenderFlow_1 = __webpack_require__(/*! ./RenderFlow */ \"./src/RenderFlow.ts\");\nexports.RenderFlow = RenderFlow_1.RenderFlow;\nconst SkyBox_1 = __webpack_require__(/*! ./SkyBox */ \"./src/SkyBox.ts\");\nexports.SkyBox = SkyBox_1.SkyBox;\nconst Geometry_1 = __webpack_require__(/*! ./Geometry */ \"./src/Geometry.ts\");\nexports.Geometry = Geometry_1.Geometry;\nconst RenderableElement_1 = __webpack_require__(/*! ./RenderableElement */ \"./src/RenderableElement.ts\");\nexports.RenderableElement = RenderableElement_1.RenderableElement;\nconst BufferGeometry_1 = __webpack_require__(/*! ./BufferGeometry */ \"./src/BufferGeometry.ts\");\nexports.BufferGeometry = BufferGeometry_1.BufferGeometry;\nconst Float32Attribute_1 = __webpack_require__(/*! ./Float32Attribute */ \"./src/Float32Attribute.ts\");\nexports.Float32Attribute = Float32Attribute_1.Float32Attribute;\nconst Uint32Attribute_1 = __webpack_require__(/*! ./Uint32Attribute */ \"./src/Uint32Attribute.ts\");\nexports.Uint32Attribute = Uint32Attribute_1.Uint32Attribute;\n__export(__webpack_require__(/*! ./Constants */ \"./src/Constants.ts\"));\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/index.ts?");

/***/ }),

/***/ "./src/math/Box3.ts":
/*!**************************!*\
  !*** ./src/math/Box3.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector3_1 = __webpack_require__(/*! ./Vector3 */ \"./src/math/Vector3.ts\");\nclass Box3 {\n    constructor(min, max) {\n        this.min = (min !== undefined) ? min : new Vector3_1.Vector3(+Infinity, +Infinity, +Infinity);\n        this.max = (max !== undefined) ? max : new Vector3_1.Vector3(-Infinity, -Infinity, -Infinity);\n    }\n}\nexports.Box3 = Box3;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/math/Box3.ts?");

/***/ }),

/***/ "./src/math/Matrix4.ts":
/*!*****************************!*\
  !*** ./src/math/Matrix4.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector3_1 = __webpack_require__(/*! ./Vector3 */ \"./src/math/Vector3.ts\");\nclass Matrix4 {\n    constructor() {\n        this.elements = [\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n        ];\n    }\n    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n        var te = this.elements;\n        te[0] = n11;\n        te[4] = n12;\n        te[8] = n13;\n        te[12] = n14;\n        te[1] = n21;\n        te[5] = n22;\n        te[9] = n23;\n        te[13] = n24;\n        te[2] = n31;\n        te[6] = n32;\n        te[10] = n33;\n        te[14] = n34;\n        te[3] = n41;\n        te[7] = n42;\n        te[11] = n43;\n        te[15] = n44;\n        return this;\n    }\n    copy(m) {\n        var te = this.elements;\n        var me = m.elements;\n        te[0] = me[0];\n        te[1] = me[1];\n        te[2] = me[2];\n        te[3] = me[3];\n        te[4] = me[4];\n        te[5] = me[5];\n        te[6] = me[6];\n        te[7] = me[7];\n        te[8] = me[8];\n        te[9] = me[9];\n        te[10] = me[10];\n        te[11] = me[11];\n        te[12] = me[12];\n        te[13] = me[13];\n        te[14] = me[14];\n        te[15] = me[15];\n        return this;\n    }\n    multiplyMatrices(a, b) {\n        var ae = a.elements;\n        var be = b.elements;\n        var te = this.elements;\n        var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n        var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n        var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n        var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n        var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n        var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n        var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n        var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n        return this;\n    }\n    multiply(m) {\n        return this.multiplyMatrices(this, m);\n    }\n    makeTranslation(x, y, z) {\n        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n        return this;\n    }\n    makeScale(x, y, z) {\n        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n        return this;\n    }\n    makePerspective(left, right, top, bottom, near, far) {\n        var te = this.elements;\n        var x = 2 * near / (right - left);\n        var y = 2 * near / (top - bottom);\n        var a = (right + left) / (right - left);\n        var b = (top + bottom) / (top - bottom);\n        var c = -(far + near) / (far - near);\n        var d = -2 * far * near / (far - near);\n        te[0] = x;\n        te[4] = 0;\n        te[8] = a;\n        te[12] = 0;\n        te[1] = 0;\n        te[5] = y;\n        te[9] = b;\n        te[13] = 0;\n        te[2] = 0;\n        te[6] = 0;\n        te[10] = c;\n        te[14] = d;\n        te[3] = 0;\n        te[7] = 0;\n        te[11] = -1;\n        te[15] = 0;\n        return this;\n    }\n    makeOrthographic(left, right, top, bottom, near, far) {\n        var te = this.elements;\n        var w = 1.0 / (right - left);\n        var h = 1.0 / (top - bottom);\n        var p = 1.0 / (far - near);\n        var x = (right + left) * w;\n        var y = (top + bottom) * h;\n        var z = (far + near) * p;\n        te[0] = 2 * w;\n        te[4] = 0;\n        te[8] = 0;\n        te[12] = -x;\n        te[1] = 0;\n        te[5] = 2 * h;\n        te[9] = 0;\n        te[13] = -y;\n        te[2] = 0;\n        te[6] = 0;\n        te[10] = -2 * p;\n        te[14] = -z;\n        te[3] = 0;\n        te[7] = 0;\n        te[11] = 0;\n        te[15] = 1;\n        return this;\n    }\n    identity() {\n        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        return this;\n    }\n    getInverse(m) {\n        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n        var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n        if (det === 0) {\n            var msg = \"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\";\n            console.warn(msg);\n            return this.identity();\n        }\n        var detInv = 1 / det;\n        te[0] = t11 * detInv;\n        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n        te[4] = t12 * detInv;\n        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n        te[8] = t13 * detInv;\n        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n        te[12] = t14 * detInv;\n        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n        return this;\n    }\n    compose(position, quaternion, scale) {\n        var te = this.elements;\n        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n        var x2 = x + x, y2 = y + y, z2 = z + z;\n        var xx = x * x2, xy = x * y2, xz = x * z2;\n        var yy = y * y2, yz = y * z2, zz = z * z2;\n        var wx = w * x2, wy = w * y2, wz = w * z2;\n        var sx = scale.x, sy = scale.y, sz = scale.z;\n        te[0] = (1 - (yy + zz)) * sx;\n        te[1] = (xy + wz) * sx;\n        te[2] = (xz - wy) * sx;\n        te[3] = 0;\n        te[4] = (xy - wz) * sy;\n        te[5] = (1 - (xx + zz)) * sy;\n        te[6] = (yz + wx) * sy;\n        te[7] = 0;\n        te[8] = (xz + wy) * sz;\n        te[9] = (yz - wx) * sz;\n        te[10] = (1 - (xx + yy)) * sz;\n        te[11] = 0;\n        te[12] = position.x;\n        te[13] = position.y;\n        te[14] = position.z;\n        te[15] = 1;\n        return this;\n    }\n    decompose(position, quaternion, scale) {\n        var vector = new Vector3_1.Vector3();\n        var matrix = new Matrix4();\n        var te = this.elements;\n        var sx = vector.set(te[0], te[1], te[2]).length();\n        var sy = vector.set(te[4], te[5], te[6]).length();\n        var sz = vector.set(te[8], te[9], te[10]).length();\n        // if determine is negative, we need to invert one scale\n        var det = this.determinant();\n        if (det < 0)\n            sx = -sx;\n        position.x = te[12];\n        position.y = te[13];\n        position.z = te[14];\n        // scale the rotation part\n        matrix.copy(this);\n        var invSX = 1 / sx;\n        var invSY = 1 / sy;\n        var invSZ = 1 / sz;\n        matrix.elements[0] *= invSX;\n        matrix.elements[1] *= invSX;\n        matrix.elements[2] *= invSX;\n        matrix.elements[4] *= invSY;\n        matrix.elements[5] *= invSY;\n        matrix.elements[6] *= invSY;\n        matrix.elements[8] *= invSZ;\n        matrix.elements[9] *= invSZ;\n        matrix.elements[10] *= invSZ;\n        quaternion.setFromRotationMatrix(matrix);\n        scale.x = sx;\n        scale.y = sy;\n        scale.z = sz;\n        return this;\n    }\n    determinant() {\n        var te = this.elements;\n        var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n        var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n        var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n        var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n        //TODO: make this more efficient\n        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n        return (n41 * (+n14 * n23 * n32\n            - n13 * n24 * n32\n            - n14 * n22 * n33\n            + n12 * n24 * n33\n            + n13 * n22 * n34\n            - n12 * n23 * n34) +\n            n42 * (+n11 * n23 * n34\n                - n11 * n24 * n33\n                + n14 * n21 * n33\n                - n13 * n21 * n34\n                + n13 * n24 * n31\n                - n14 * n23 * n31) +\n            n43 * (+n11 * n24 * n32\n                - n11 * n22 * n34\n                - n14 * n21 * n32\n                + n12 * n21 * n34\n                + n14 * n22 * n31\n                - n12 * n24 * n31) +\n            n44 * (-n13 * n22 * n31\n                - n11 * n23 * n32\n                + n11 * n22 * n33\n                + n13 * n21 * n32\n                - n12 * n21 * n33\n                + n12 * n23 * n31));\n    }\n    clone() {\n        return new Matrix4().fromArray(this.elements);\n    }\n    fromArray(array, offset = 0) {\n        for (var i = 0; i < 16; i++) {\n            this.elements[i] = array[i + offset];\n        }\n        return this;\n    }\n    extractRotation(m) {\n        var v1 = new Vector3_1.Vector3();\n        var te = this.elements;\n        var me = m.elements;\n        var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();\n        var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();\n        var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();\n        te[0] = me[0] * scaleX;\n        te[1] = me[1] * scaleX;\n        te[2] = me[2] * scaleX;\n        te[4] = me[4] * scaleY;\n        te[5] = me[5] * scaleY;\n        te[6] = me[6] * scaleY;\n        te[8] = me[8] * scaleZ;\n        te[9] = me[9] * scaleZ;\n        te[10] = me[10] * scaleZ;\n        return this;\n    }\n    lookAt(eye, target, up) {\n        var x = new Vector3_1.Vector3();\n        var y = new Vector3_1.Vector3();\n        var z = new Vector3_1.Vector3();\n        var te = this.elements;\n        z.subVectors(eye, target);\n        if (z.lengthSq() === 0) {\n            // eye and target are in the same position\n            z.z = 1;\n        }\n        z.normalize();\n        x.crossVectors(up, z);\n        if (x.lengthSq() === 0) {\n            // up and z are parallel\n            if (Math.abs(up.z) === 1) {\n                z.x += 0.0001;\n            }\n            else {\n                z.z += 0.0001;\n            }\n            z.normalize();\n            x.crossVectors(up, z);\n        }\n        x.normalize();\n        y.crossVectors(z, x);\n        te[0] = x.x;\n        te[4] = y.x;\n        te[8] = z.x;\n        te[1] = x.y;\n        te[5] = y.y;\n        te[9] = z.y;\n        te[2] = x.z;\n        te[6] = y.z;\n        te[10] = z.z;\n        return this;\n    }\n}\nexports.Matrix4 = Matrix4;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/math/Matrix4.ts?");

/***/ }),

/***/ "./src/math/Quaternion.ts":
/*!********************************!*\
  !*** ./src/math/Quaternion.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector3_1 = __webpack_require__(/*! ./Vector3 */ \"./src/math/Vector3.ts\");\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n */\nfunction Quaternion(x = 0, y = 0, z = 0, w = 1) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = (w !== undefined) ? w : 1;\n}\nexports.Quaternion = Quaternion;\nObject.assign(Quaternion, {\n    slerp: function (qa, qb, qm, t) {\n        return qm.copy(qa).slerp(qb, t);\n    },\n    slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n        // fuzz-free, array-based Quaternion SLERP operation\n        var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\n        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n            var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = (cos >= 0 ? 1 : -1), sqrSin = 1 - cos * cos;\n            // Skip the Slerp for tiny steps to avoid numeric problems:\n            if (sqrSin > Number.EPSILON) {\n                var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\n                s = Math.sin(s * len) / sin;\n                t = Math.sin(t * len) / sin;\n            }\n            var tDir = t * dir;\n            x0 = x0 * s + x1 * tDir;\n            y0 = y0 * s + y1 * tDir;\n            z0 = z0 * s + z1 * tDir;\n            w0 = w0 * s + w1 * tDir;\n            // Normalize in case we just did a lerp:\n            if (s === 1 - t) {\n                var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n                x0 *= f;\n                y0 *= f;\n                z0 *= f;\n                w0 *= f;\n            }\n        }\n        dst[dstOffset] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n    }\n});\nObject.defineProperties(Quaternion.prototype, {\n    x: {\n        get: function () {\n            return this._x;\n        },\n        set: function (value) {\n            this._x = value;\n            this.onChangeCallback();\n        }\n    },\n    y: {\n        get: function () {\n            return this._y;\n        },\n        set: function (value) {\n            this._y = value;\n            this.onChangeCallback();\n        }\n    },\n    z: {\n        get: function () {\n            return this._z;\n        },\n        set: function (value) {\n            this._z = value;\n            this.onChangeCallback();\n        }\n    },\n    w: {\n        get: function () {\n            return this._w;\n        },\n        set: function (value) {\n            this._w = value;\n            this.onChangeCallback();\n        }\n    }\n});\nObject.assign(Quaternion.prototype, {\n    set: function (x, y, z, w) {\n        this._x = x;\n        this._y = y;\n        this._z = z;\n        this._w = w;\n        this.onChangeCallback();\n        return this;\n    },\n    clone: function () {\n        return new this.constructor(this._x, this._y, this._z, this._w);\n    },\n    copy: function (quaternion) {\n        this._x = quaternion.x;\n        this._y = quaternion.y;\n        this._z = quaternion.z;\n        this._w = quaternion.w;\n        this.onChangeCallback();\n        return this;\n    },\n    setFromEuler: function (euler, update) {\n        if (!(euler && euler.isEuler)) {\n            throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');\n        }\n        var x = euler._x, y = euler._y, z = euler._z, order = euler.order;\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n        var cos = Math.cos;\n        var sin = Math.sin;\n        var c1 = cos(x / 2);\n        var c2 = cos(y / 2);\n        var c3 = cos(z / 2);\n        var s1 = sin(x / 2);\n        var s2 = sin(y / 2);\n        var s3 = sin(z / 2);\n        if (order === 'XYZ') {\n            this._x = s1 * c2 * c3 + c1 * s2 * s3;\n            this._y = c1 * s2 * c3 - s1 * c2 * s3;\n            this._z = c1 * c2 * s3 + s1 * s2 * c3;\n            this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        }\n        else if (order === 'YXZ') {\n            this._x = s1 * c2 * c3 + c1 * s2 * s3;\n            this._y = c1 * s2 * c3 - s1 * c2 * s3;\n            this._z = c1 * c2 * s3 - s1 * s2 * c3;\n            this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n        else if (order === 'ZXY') {\n            this._x = s1 * c2 * c3 - c1 * s2 * s3;\n            this._y = c1 * s2 * c3 + s1 * c2 * s3;\n            this._z = c1 * c2 * s3 + s1 * s2 * c3;\n            this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        }\n        else if (order === 'ZYX') {\n            this._x = s1 * c2 * c3 - c1 * s2 * s3;\n            this._y = c1 * s2 * c3 + s1 * c2 * s3;\n            this._z = c1 * c2 * s3 - s1 * s2 * c3;\n            this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n        else if (order === 'YZX') {\n            this._x = s1 * c2 * c3 + c1 * s2 * s3;\n            this._y = c1 * s2 * c3 + s1 * c2 * s3;\n            this._z = c1 * c2 * s3 - s1 * s2 * c3;\n            this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        }\n        else if (order === 'XZY') {\n            this._x = s1 * c2 * c3 - c1 * s2 * s3;\n            this._y = c1 * s2 * c3 - s1 * c2 * s3;\n            this._z = c1 * c2 * s3 + s1 * s2 * c3;\n            this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n        if (update !== false)\n            this.onChangeCallback();\n        return this;\n    },\n    setFromAxisAngle: function (axis, angle) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n        // assumes axis is normalized\n        var halfAngle = angle / 2, s = Math.sin(halfAngle);\n        this._x = axis.x * s;\n        this._y = axis.y * s;\n        this._z = axis.z * s;\n        this._w = Math.cos(halfAngle);\n        this.onChangeCallback();\n        return this;\n    },\n    setFromRotationMatrix: function (m) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n        var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;\n        if (trace > 0) {\n            s = 0.5 / Math.sqrt(trace + 1.0);\n            this._w = 0.25 / s;\n            this._x = (m32 - m23) * s;\n            this._y = (m13 - m31) * s;\n            this._z = (m21 - m12) * s;\n        }\n        else if (m11 > m22 && m11 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n            this._w = (m32 - m23) / s;\n            this._x = 0.25 * s;\n            this._y = (m12 + m21) / s;\n            this._z = (m13 + m31) / s;\n        }\n        else if (m22 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n            this._w = (m13 - m31) / s;\n            this._x = (m12 + m21) / s;\n            this._y = 0.25 * s;\n            this._z = (m23 + m32) / s;\n        }\n        else {\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n            this._w = (m21 - m12) / s;\n            this._x = (m13 + m31) / s;\n            this._y = (m23 + m32) / s;\n            this._z = 0.25 * s;\n        }\n        this.onChangeCallback();\n        return this;\n    },\n    setFromUnitVectors: function () {\n        // assumes direction vectors vFrom and vTo are normalized\n        var v1 = new Vector3_1.Vector3();\n        var r;\n        var EPS = 0.000001;\n        return function setFromUnitVectors(vFrom, vTo) {\n            if (v1 === undefined)\n                v1 = new Vector3_1.Vector3();\n            r = vFrom.dot(vTo) + 1;\n            if (r < EPS) {\n                r = 0;\n                if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n                    v1.set(-vFrom.y, vFrom.x, 0);\n                }\n                else {\n                    v1.set(0, -vFrom.z, vFrom.y);\n                }\n            }\n            else {\n                v1.crossVectors(vFrom, vTo);\n            }\n            this._x = v1.x;\n            this._y = v1.y;\n            this._z = v1.z;\n            this._w = r;\n            return this.normalize();\n        };\n    }(),\n    inverse: function () {\n        // quaternion is assumed to have unit length\n        return this.conjugate();\n    },\n    conjugate: function () {\n        this._x *= -1;\n        this._y *= -1;\n        this._z *= -1;\n        this.onChangeCallback();\n        return this;\n    },\n    dot: function (v) {\n        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n    },\n    lengthSq: function () {\n        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    },\n    length: function () {\n        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    },\n    normalize: function () {\n        var l = this.length();\n        if (l === 0) {\n            this._x = 0;\n            this._y = 0;\n            this._z = 0;\n            this._w = 1;\n        }\n        else {\n            l = 1 / l;\n            this._x = this._x * l;\n            this._y = this._y * l;\n            this._z = this._z * l;\n            this._w = this._w * l;\n        }\n        this.onChangeCallback();\n        return this;\n    },\n    multiply: function (q, p) {\n        if (p !== undefined) {\n            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\n            return this.multiplyQuaternions(q, p);\n        }\n        return this.multiplyQuaternions(this, q);\n    },\n    premultiply: function (q) {\n        return this.multiplyQuaternions(q, this);\n    },\n    multiplyQuaternions: function (a, b) {\n        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n        var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n        var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n        this.onChangeCallback();\n        return this;\n    },\n    slerp: function (qb, t) {\n        if (t === 0)\n            return this;\n        if (t === 1)\n            return this.copy(qb);\n        var x = this._x, y = this._y, z = this._z, w = this._w;\n        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n        if (cosHalfTheta < 0) {\n            this._w = -qb._w;\n            this._x = -qb._x;\n            this._y = -qb._y;\n            this._z = -qb._z;\n            cosHalfTheta = -cosHalfTheta;\n        }\n        else {\n            this.copy(qb);\n        }\n        if (cosHalfTheta >= 1.0) {\n            this._w = w;\n            this._x = x;\n            this._y = y;\n            this._z = z;\n            return this;\n        }\n        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n        if (Math.abs(sinHalfTheta) < 0.001) {\n            this._w = 0.5 * (w + this._w);\n            this._x = 0.5 * (x + this._x);\n            this._y = 0.5 * (y + this._y);\n            this._z = 0.5 * (z + this._z);\n            return this;\n        }\n        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n        this._w = (w * ratioA + this._w * ratioB);\n        this._x = (x * ratioA + this._x * ratioB);\n        this._y = (y * ratioA + this._y * ratioB);\n        this._z = (z * ratioA + this._z * ratioB);\n        this.onChangeCallback();\n        return this;\n    },\n    equals: function (quaternion) {\n        return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);\n    },\n    fromArray: function (array, offset) {\n        if (offset === undefined)\n            offset = 0;\n        this._x = array[offset];\n        this._y = array[offset + 1];\n        this._z = array[offset + 2];\n        this._w = array[offset + 3];\n        this.onChangeCallback();\n        return this;\n    },\n    toArray: function (array, offset) {\n        if (array === undefined)\n            array = [];\n        if (offset === undefined)\n            offset = 0;\n        array[offset] = this._x;\n        array[offset + 1] = this._y;\n        array[offset + 2] = this._z;\n        array[offset + 3] = this._w;\n        return array;\n    },\n    onChange: function (callback) {\n        this.onChangeCallback = callback;\n        return this;\n    },\n    onChangeCallback: function () { }\n});\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/math/Quaternion.ts?");

/***/ }),

/***/ "./src/math/Vector2.ts":
/*!*****************************!*\
  !*** ./src/math/Vector2.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Vector2 {\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n    set(x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    add(v) {\n        this.x += v.x;\n        this.y += v.y;\n        return this;\n    }\n    sub(v) {\n        this.x -= v.x;\n        this.y -= v.y;\n        return this;\n    }\n    multiply(v) {\n        this.x *= v.x;\n        this.y *= v.y;\n        return this;\n    }\n    multiplyScalar(scalar) {\n        this.x *= scalar;\n        this.y *= scalar;\n        return this;\n    }\n    dot(v) {\n        return this.x * v.x + this.y * v.y;\n    }\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    clone() {\n        return new Vector2(this.x, this.y);\n    }\n    copy(v) {\n        this.x = v.x;\n        this.y = v.y;\n        return this;\n    }\n    equals(v) {\n        return ((v.x === this.x) && (v.y === this.y));\n    }\n    subVectors(a, b) {\n        this.x = a.x - b.x;\n        this.y = a.y - b.y;\n        return this;\n    }\n}\nexports.Vector2 = Vector2;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/math/Vector2.ts?");

/***/ }),

/***/ "./src/math/Vector3.ts":
/*!*****************************!*\
  !*** ./src/math/Vector3.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Vector3 {\n    constructor(x = 0, y = 0, z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    set(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        return this;\n    }\n    add(v) {\n        this.x += v.x;\n        this.y += v.y;\n        this.z += v.z;\n        return this;\n    }\n    sub(v) {\n        this.x -= v.x;\n        this.y -= v.y;\n        this.z -= v.z;\n        return this;\n    }\n    subVectors(a, b) {\n        this.x = a.x - b.x;\n        this.y = a.y - b.y;\n        this.z = a.z - b.z;\n        return this;\n    }\n    fromArray(array, offset) {\n        if (offset === undefined)\n            offset = 0;\n        this.x = array[offset];\n        this.y = array[offset + 1];\n        this.z = array[offset + 2];\n        return this;\n    }\n    setFromMatrixColumn(m, index) {\n        return this.fromArray(m.elements, index * 4);\n    }\n    lengthSq() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    multiply(v) {\n        this.x *= v.x;\n        this.y *= v.y;\n        this.z *= v.z;\n        return this;\n    }\n    multiplyScalar(scalar) {\n        this.x *= scalar;\n        this.y *= scalar;\n        this.z *= scalar;\n        return this;\n    }\n    dot(v) {\n        return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    clone() {\n        return new Vector3(this.x, this.y, this.z);\n    }\n    copy(v) {\n        this.x = v.x;\n        this.y = v.y;\n        this.z = v.z;\n        return this;\n    }\n    equals(v) {\n        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));\n    }\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    crossVectors(a, b) {\n        var ax = a.x, ay = a.y, az = a.z;\n        var bx = b.x, by = b.y, bz = b.z;\n        this.x = ay * bz - az * by;\n        this.y = az * bx - ax * bz;\n        this.z = ax * by - ay * bx;\n        return this;\n    }\n    divideScalar(scalar) {\n        return this.multiplyScalar(1 / scalar);\n    }\n    normalize() {\n        return this.divideScalar(this.length());\n    }\n    applyQuaternion(q) {\n        var x = this.x, y = this.y, z = this.z;\n        var qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n        // calculate quat * vector\n        var ix = qw * x + qy * z - qz * y;\n        var iy = qw * y + qz * x - qx * z;\n        var iz = qw * z + qx * y - qy * x;\n        var iw = -qx * x - qy * y - qz * z;\n        // calculate result * inverse quat\n        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n        return this;\n    }\n    addScaledVector(v, s) {\n        this.x += v.x * s;\n        this.y += v.y * s;\n        this.z += v.z * s;\n        return this;\n    }\n    setFromSpherical(s) {\n        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n    }\n    setFromSphericalCoords(radius, phi, theta) {\n        var sinPhiRadius = Math.sin(phi) * radius;\n        this.x = sinPhiRadius * Math.sin(theta);\n        this.y = Math.cos(phi) * radius;\n        this.z = sinPhiRadius * Math.cos(theta);\n        return this;\n    }\n    distanceTo(v) {\n        return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n        var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n        return dx * dx + dy * dy + dz * dz;\n    }\n}\nexports.Vector3 = Vector3;\n\n\n//# sourceURL=webpack://@gl-widget/gl-widget/./src/math/Vector3.ts?");

/***/ })

/******/ });
});